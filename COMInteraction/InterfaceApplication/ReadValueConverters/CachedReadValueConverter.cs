using System;
using System.Linq;
using System.Reflection;
using COMInteraction.Misc;

namespace COMInteraction.InterfaceApplication.ReadValueConverters
{
    /// <summary>
    /// If values returned from properties or methods from an IInterfaceApplier generated by the InterfaceApplierFactory are passed through this read converter and the values
    /// should be returned implementing a specific interface then this will attempt to fit those values to the interfaces using the specified InterfaceApplierFactory (eg. if
    /// returning the value for the Application property of an IControl, if that property is of type IApplication then this read value converter will use the interface
    /// applier factory to return the Application value with the IApplication interface applied)
    /// </summary>
    public class CachedReadValueConverter : IReadValueConverter
    {
        private NonNullImmutableList<Type> _callChain;
        private NonNullImmutableList<IInterfaceApplier> _interfaceAppliers;
        private volatile InterfaceApplierFactory _interfaceApplierFactory; // Must be volatile for double-checked locking pattern
        private object _writeLock;

        public CachedReadValueConverter(InterfaceApplierFactory interfaceApplierFactory) : this(interfaceApplierFactory, new NonNullImmutableList<Type>()) { }
        private CachedReadValueConverter(InterfaceApplierFactory interfaceApplierFactory, NonNullImmutableList<Type> callChain)
        {
            if (interfaceApplierFactory == null)
                throw new ArgumentNullException("interfaceApplierFactory");
            _interfaceApplierFactory = interfaceApplierFactory;
            _interfaceAppliers = new NonNullImmutableList<IInterfaceApplier>();
            _callChain = callChain;
            _writeLock = new object();
        }

        /// <summary>
        /// The return value should be assignable to property.PropertyType otherwise the IInterfaceApplier.Apply method may fail
        /// </summary>
        public object Convert(PropertyInfo property, object value)
        {
            if (property == null)
                throw new ArgumentNullException("property");
            return tryToConvertValueIfRequired(property.PropertyType, value);
        }

        /// <summary>
        /// The return value should be assignable to method.ReturnType otherwise the IInterfaceApplier.Apply method may fail
        /// </summary>
        public object Convert(MethodInfo method, object value)
        {
            if (method == null)
                throw new ArgumentNullException("method");
            return tryToConvertValueIfRequired(method.ReturnType, value);
        }

        private object tryToConvertValueIfRequired(Type targetType, object value)
        {
            if (targetType == null)
                throw new ArgumentNullException("targetType");
            
            // If no conversion is required, no work to do
            if (!targetType.IsInterface || (value == null) || (value.GetType().IsSubclassOf(targetType)))
                return value;

            // Do we already have an interface applier available for this type?
            var interfaceApplier = tryToGetInterfaceApplier(targetType);
            if (interfaceApplier != null)
                return interfaceApplier.Apply(value);
                
            // If not, we'll need to try to initialise one
            // - Before doing so, look up through the call chain and ensure that we're not already in the process of trying to wrap
            //   a reference to this type, if we are then we'll end up in an infinite loop which we need to prevent
            //    eg. If IContainer has a property with type IContainer then this would go round and round trying to get an interface
            //        applier to IContainer until it ran out of stack space
            if (_callChain.Contains(targetType))
                throw new Exception("Infinite target reference exception for type " + targetType.ToString());

            // Try to generate new interface applier - add current type to the callchain of new TestReadValueConverter so that the
            // above infinite-loop check can be performed
            interfaceApplier = _interfaceApplierFactory.GenerateInterfaceApplier(
                targetType,
                new CachedReadValueConverter(_interfaceApplierFactory, _callChain.Add(targetType))
            );
            if (tryToGetInterfaceApplier(targetType) == null) // Double-checked locking (try to prevent unnecessary locks)
            {
                lock (_writeLock)
                {
                    if (tryToGetInterfaceApplier(targetType) == null)
                        _interfaceAppliers = _interfaceAppliers.Add(interfaceApplier);
                }
            }
            return interfaceApplier.Apply(value);
        }

        /// <summary>
        /// This will return null if no interface applier is available for this class instance
        /// </summary>
        private IInterfaceApplier tryToGetInterfaceApplier(Type targetType)
        {
            if (targetType == null)
                throw new ArgumentNullException("targetType");
            return _interfaceAppliers.FirstOrDefault(i => i.TargetType.Equals(targetType));
        }
    }
}
