using System;
using System.Linq;
using System.Reflection;
using COMInteraction.Misc;

namespace COMInteraction.InterfaceApplication.ReadValueConverters
{
    /// <summary>
    /// If values returned from properties or methods from an IInterfaceApplier generated by the InterfaceApplierFactory are passed through this read converter and the values
    /// should be returned implementing a specific interface then this will attempt to fit those values to the interfaces using the specified InterfaceApplierFactory (eg. if
    /// returning the value for the Application property of an IControl, if that property is of type IApplication then this read value converter will use the interface
    /// applier factory to return the Application value with the IApplication interface applied)
    /// </summary>
    public class CachedReadValueConverter : IReadValueConverter
    {
        private IInterfaceApplierFactory _interfaceApplierFactory;
        private NonNullImmutableList<IInterfaceApplier> _interfaceAppliers;
        private object _writeLock;

        public CachedReadValueConverter(IInterfaceApplierFactory interfaceApplierFactory)
        {
            if (interfaceApplierFactory == null)
                throw new ArgumentNullException("interfaceApplierFactory");

            _interfaceApplierFactory = interfaceApplierFactory;
            _interfaceAppliers = new NonNullImmutableList<IInterfaceApplier>();
            _writeLock = new object();
        }

        /// <summary>
        /// The return value should be assignable to property.PropertyType otherwise the IInterfaceApplier.Apply method may fail
        /// </summary>
        public object Convert(PropertyInfo property, object value)
        {
            if (property == null)
                throw new ArgumentNullException("property");

            return tryToConvertValueIfRequired(property.PropertyType, value);
        }

        /// <summary>
        /// The return value should be assignable to method.ReturnType otherwise the IInterfaceApplier.Apply method may fail
        /// </summary>
        public object Convert(MethodInfo method, object value)
        {
            if (method == null)
                throw new ArgumentNullException("method");

            return tryToConvertValueIfRequired(method.ReturnType, value);
        }

        private object tryToConvertValueIfRequired(Type targetType, object value)
        {
            if (targetType == null)
                throw new ArgumentNullException("targetType");
            
            // If no conversion is required, no work to do
            // - Note: We can only deal with applying interfaces to objects so if a conversion is required where the target is not an interface
            //   then there's nothing we can do here, we'll have to return the value unconverted (likewise, if the target type is an int but
            //   the current value is null, although this is obviously incorrect there's nothing we can do about it here)
            if (!targetType.IsInterface || (value == null) || (value.GetType().IsSubclassOf(targetType)))
                return value;

            // Do we already have an interface applier available for this type?
            var interfaceApplierExisting = _interfaceAppliers.FirstOrDefault(i => i.TargetType.Equals(targetType));
            if (interfaceApplierExisting != null)
                return interfaceApplierExisting.Apply(value);
                
            // Try to generate new interface applier
            var interfaceApplierNew = _interfaceApplierFactory.GenerateInterfaceApplier(targetType, this);
            lock (_writeLock)
            {
                if (!_interfaceAppliers.Any(i => i.TargetType.Equals(targetType)))
                    _interfaceAppliers = _interfaceAppliers.Add(interfaceApplierNew);
            }
            return interfaceApplierNew.Apply(value);
        }
    }
}
